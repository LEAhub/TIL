스프링을 사용하는 이유:
				나는 하나의 인스턴스로 여러 곳에서 사용하고 싶은데
				매번 new연산자를 사용하면 새로운 인스턴스가 생성되는 거니 의미가 없어!
				그럼 스프링을 사용하자!
				스프링은 스프링 컨테이너에 Component된 해당 객체를 Bean으로 저장하여
				여러 곳에서 동일한 값을 가진 정보를 사용할 수 있게 해준다고~



리플렉션 : 기법, 필드, 메소드, 어노테이션 등을 확인하여 필터링 해주는 기법이다. 런타임 때 이 기법을 사용함
어노테이션 :  주석이자 힌트를 준다. @Component @Controller @AutoWired와 같은 어노테이션이 붙으면
		자바가 컴파일할 때 확인을 하여 해당하는 기능을 구현함
JSON : 중간 언어로 JSON을 사용한다. 예를 들자. 자바 프로그램에서 파이썬 프로그램으로 데이터를 전송할 때
	중간 언어가 필요하다. 자바와 파이썬에서도 읽을 수 있는 언어가 JSON이다.
@ResponseBody : BufferdWriter의 객체가 실행, JSP에서 내장 객체 out은 BufferedWriter를 사용함.
@RequestBody : BufferedReader의 객체가 실행


-----------------------------------------JPA------------------------------------------------
JPA : Java Persistence API

보통 RAM에 저장을 한다. 휘발성이다. 전기로 데이터가 이동된다. 그래서 종료가 되면 데이터는 모두 사라지게 된다.
반면 JPA는 프로그램이 꺼져도 데이터는 남아있다. 비휘발성이다.
자바를 프로그램을 프로그래밍 할 때 영구적으로 데이터를 저장하기 위해 필요한 인터페이스

API : Application Programming Interface
	프로그램 	프로그래밍	약속
      즉, 프로그램을 프로그래밍할 때의 약속이다.

프로토콜  /  인터페이스


인터페이스 : 상하 관계가 존재하는 약속, A B C가 있을 떄 B가 가장 힘이 세다면 B의 약속으로 진행됨

프로토콜 : 권리가 동등하다. World Wide Web
		수많은 프로토콜로 만들어진 게 인터넷

ORM : Object Relational Mapping 

Modeling : 추상적인 개념을 현실화함

DB에 연동하여 쿼리문을 작성한다. 그때에 insert(create), deleter(delete), update(update), selcet(read)를 작성한다.
(CRUD이다) 이런 단순하고 반복된 작업을 JPA를 사용하여 하나의 함수로 작업을 진행할 수 있는 큰 장점이 있다.

JAP는 영속성 컨텍스트를 가지고 있다.
영속성 : 데이터를 영구적으로 저장 Persistence, DB에 저장

Context : 컨텍스트는 무엇인가? 모든 정보를 가지고 있음 

자바 프로그램은 DB에 데이터를 전달할 때 중간에 영속성 컨텍스트라는 단계를 거친다.
영속성 컨텍스트와 DB는 서로 동기화가 가능하다.
자바 프로그램에서 영속성 컨텍스트가 가지고 있지 않은 데이터를 selecet하게 된다면
영속성 컨텍스트는 DB에게 정보를 받아온다. 결론적으로 세 곳에서의 데이터는 일치한다.
자바에서 데이터를 변경하면 영속성컨텍스트의 데이터도 변경된다.
그럼 DB에서의 데이터는? 자동으로 update문을 만들어 DB에서의 데이터를 변경한다.
이것이 바로 영속성 컨텍스트이다.

DB에는 Object를 삽입할 수 없다. 기본 자료형만 삽입 가능하다.
예를 들면 자바에서는 다른 객체를 담을 수 있지만(기본 자료형이 아닌 참조 자료형을 담는 것을 OOP라 부른다) 
DB에서는 불가능하단 말이다.
그래서 사용하는 게 JPA이고 그걸 ORM이 해결해준다. 자동으로 데이터를 매핑하여 해당 Object에 담는다.

JPA는 OOP관점에서 모델링 가능하다. 컴포지션(객체를 포함)이면 새로운 테이블에 해당 객체에 대한 정보를 만들고
상속을 받으면 자바 클래스에서 필드가 추가되는 것과 같이 테이블에 column을 추가한다. 

JPA는 MySQL 뿐만 아니라 여러 DB를 지원한다.
추상화 객체를 두고 추상화 객체는 데이터 베이스 연결되어있음.

---------------------------------------------------------------스프링 부트란? ----------------------------------------



1. 소켓이란?

Socket : 운영 체제가 가지고 있는 것

B가 소켓을 오픈하였다. 5000 port로 열었다고 가정하자.
A가 B의 ip주소:5000번으로 연결하면 서로 연락을 주고 받을 수 있다.
여기서 C가 추가되었다고 하자. C는 연결할 방법이 없다.
자세히 들여다보면 최초의 5000번 포트는 연결의 의미로만 쓰인다.
5000 포트를 연결하는 순간 새로운 Socket을 만든다. B는 A와의 5000에서의 연결을 끊음
그 새로운 Socket에는 랜덤의 port를 받는다(5001 가정). 그 port로 서로 연락을 주고 받을 수 있다.

5000 쓰레드 : main 쓰레드, 계속 요청을 받는다.
랜덤의 포트 쓰레드 (5001 port): ex)쓰레드1 -> 이 쓰레드로 주고 받음

C가 연결한다고 한다면 B에서 새로운 소켓을 만든다. 포트가 랜덤으로 생성된다, 새로운 스레드 생성(스레드 2 가정)
(사용자가 생성할 수 있음, 5002 port 가정)
C가 5000 port의 연결을 하고 B는 5000에서 C와의 연결을 끊음 새로운 스레드2에서 서로 연결을 주고 받음

위를 소켓 통신이라 한다.

장점은 계속 연결이 되어있다. 계속 연결되어 있기 때문에 B 입장에서는 A가 누구인지 알 수 있음
그걸 단점으로 본다면 부하가 커서 느려질 수 있다.


2. http란?

http 통신 : http의 기반은 소켓이다. 
		html 확장자로 만들어진 문서를 필요한 사람에게 전달.
		연결을 지속시키지 않고 끊어 버리는 stateless 방식을 사용한다. 단순하게 문서를 전달하는 통신이다.
		소켓 통신은 서로 지속적인 연결 상태라면 
		http 통신은 요청을 받으면 그에 대한 응답을 하고 바로 연결을 끊어버린다.
		연결이 끊기기 때문에 부하가 적지만 다시 연결되면 새로운 대상으로 인식을 함
		정보들을 한 데에 모아서 필요한 대상이 요청하면 데이터 응답을 하고 연결을 끊음
		
	
----------------------------->>>>이러한 단점을 보완하여 만들어진 '웹 서버'가 있다!


3. 웹서버란?

내가 컴퓨터 한 대를 구매함. 재미있는 동영상들을 가지고 있음. 친구들 각자 컴퓨터를 소지함
친구들이 내 동영상을 보고 싶어함. 친구들은 내 데이터를 필요로 함
친구들曰 우리는 Wolrd Wide Web으로 연결되어 있기 때문에 모두 선이 연결이 되어있어.
		그러니까 인터넷 통신을 통해서 네가 가진 동영상을 줄 수 있니?
나 : 甲, 웹 서버
친구 : 乙

을이 갑에게 요청함. 내 위치를 알아야 해서 ip 주소를 알아야 한다. 
어떠한 동영상을 필요로 한지 정확하게 명시해줘야 함(URL) 자원을 요청하는 주소 / L -> Location
ex) http://localhost:8080/hello.html   ---> hello.html이 자원이 됨
ex) http://localhost:8080/hello.avi 	   ---> hello.avi가 자원이 됨

갑은 을에게 응답한다. 원래 갑은 을의 ip주소를 몰라도 된다. 
왜냐면 갑은 을 컴퓨터로 가서 데이터를 가져올 일이 없기 때문이다.
갑은 가만히 있다가 을이 요청을 하면 을이 요청한 ip주소를 토대로 자기가 누군지를 밝힘
요청한 정보게 맞게 정보를 응답하면 되는 거임.  ---> 갑은 Web Server가 된다.

!!http!!!에서 갑(웹서버)는 을의 ip주소를 모른다. 을이 요청하지 않으면 응답은 불가능하다. 을의 주소를 모르기 때문이다.
을의 주소를 알기 위해서는 소켓을 써야 한다. 소켓은 연결을 끊지 않고 지속하기 때문에 원할 때 응답 가능하다.
응답하는 자원은 static 자원이다. 정적인 자원. 
요청 시 마다 변하는 자원이 아니라 요청할 때마다 다른 을이 자원을 요청할 때 변하지 않은 정적인 자원을 응답한다.

4. 톰캣이란?

apache라는 webServer가 있다. 컴퓨터 C드라이브 안에 Work 폴더를 사람들에게 공유한다.
Work 폴더에는 수많은 자원들이 존재한다. 누군가가 자원을 요청한다고 request를 하게 되면 
아파치는 자원을 응답하는 구조
만일 .jsp파일(자바코드)을 요청하게 된다면 아파치는 자바코드를 이해하지 못함.
자바코드 요청 시 응답하지 못한다.
아파치 + (톰캣)을 달아서 아파치 자신이 이해하지 못하는 파일에 대한 요청이 오면
제어권을 톰캣에게 넘겨버린다.

톰캣은 .jsp 파일 안에 있는 모든 자바 파일을 컴파일 하고 컴파일이 끝나면
그 컴파일 된 데이터를 .html에 덮어 쓴다.
다시 아파치에게 돌려준다.
아파치는 .html 파일을 응답한다.

웹브라우저는 html, css, javascript 외의 정적인 파일만 이해할 수 있다.
결론적으로 .jsp파일을 요청했지만 톰캣에 의해 컴파일 되어 html을 반환하므로
응답은 .html을 받는다.



--------------------------------- servlet Container란 무엇인가?-------------------------

client가 요청을 한다. servlet Contaioner(tomcat)이 요청을 받는다.
최초의 요청이면 객체를 생성하고 최초의 요청이 아니면 객체를 생성하지 않는다.

정적인 파일을 요청하면 아파치가 돌게 됨. 톰캣은 일을 하지 않음
자바 파일을 요청하면 톰캣이 일을 하게 됨
스프링에서도 정적인 파일을 요청하면 톰캣은 일을 하지 않지만 
스프링에서는 정적인 파일을 요청할 수 없음
URL : 자원에 접근할 때 요청하는 주소  // 스프링이 다 막음
URI : Identify, 식별자. 식별자를 통해서 접근하는 방식, 특정한 파일 요청을 할 수 없다.
	요청 시에는 무조건 자바를 거친다.
	아파치는 무조건 제어권을 톰캣에게 전달함.
	http://naver.com/a.png ---> URL
	http://naver.com/picture/a ---> URI
	
요청이 왔을 때 서블릿 컨테이너가 객체를 생성하는 방식에 대해 자세히 알아야 한다.

요청이 오면(자바 관련 자원) 서버는 서블릿 컨테이너(톰캣)이 무조건 실행함

@@최초의 요청일 경우@@
1. 서블릿 객체를 생성한다. (new 연산자)
	-> init() 초기화 메소드가 제일 처음에 호출됨
	-> service() 메소드를 호출함, POST 방식인지 GET 방식인지 PUT 등등 html의 폼 메소드를 확인함
		-> 새로운 스레드를 만듦 스레드 1이 실행(가정) 스레드가 service() 호출함
	-> GET 방식이면 get() 메소드 호출됨
		-> DB 연결, 데이터, html에 담아 응답하기
	->

@@최초의 요청이 아닐 경우@@ 

2. 서블릿 객체를 생성하지 않고 재사용한다.
	->new(연산자) 없음
	->초기화를 하지 않기 때문에 init() 메소드 호출 안 함
	->새로운 스레드를 생성함 스레드 2가 실행(가정)
		-> 스레드 2가 service() 메소드를 호출함
	->get() 메소드 호출
	
	클래스 안에 있는 메소드는 독립적으로 실행된다.
	그러므로 위에서 몇 번의 요청이 있을 경우 스레드가 추가되어
	메소드를 같이 호출할 수 있다.
	톰캣 기본 설정 : 스레드 100개 설정
				Auto 20개로 설정하게 되면 
				사용자로 20개의 요청이 오면
				스레드를 20개까지 생성을 하다가 21번째에는 대기를 해야 한다.
				첫번째 스레드가 종료가 되면 (종료되는 시점은 response)
				21번째에 대기자는 종료되는 해당 스레드에 들어가서 재사용한다.
				(pooling 기법)
	
	서블릿 객체는 무조건 한 개임

	100명 - 100개의 스레드 (풀링 기술) (scale-up)
	100명 = 10 * 10 수평 확장(scale-out)




------------------------------------------- web.xml이란?---------------------------------------------

성이 있다고 가정하자. 성에는 관리자가 있다. 관리자(개발자)가 문지기에게 문서를 주며 이렇게 관리하라고 지시를 한다.
그 문서가 web.xml이다. A가 성에 입장하는 상황을 가정한다.

* ServletContext의 초기 파라미터
	 -> 한 번 설정하면 어디서든 사용할 수 있음

* session의 유효 시간 설정
	-> 인증을 통해서 들어오는 게 세션이다. 식별!! 각각 식별을 발부함
	-> session : 3일 가정 / 3일이 지나면 추방
	-> 더 있고 싶다면 문지기에게 알려야 한다.

* Servlet/JSP에 대한 정의
* Servlet/JSP 매핑
	-> A가 성으로 들어오는데 성의 어느 곳으로 들어갈지 문지기에게 알려야 함
	-> 문지기가 A가 들어가고 싶은 곳을 알려줌
		-> serlvet 매핑

*Mime Type 매핑
	-> A가 들어올 때 많은 쌀을 들고 옴
	-> 문지기曰 너 Mime Type이 뭐야?
	-> A曰 쌀이요.
		-> Mime Type : 네가 들고올 데이터의 타입이 뭐니?
		-> 아무것도 안 들고 있으면 html의 get 방식을 사용함 주는 게 아니라 얻으려고 온 것 select라고 함
	-> 문지기曰 쌀창고로 이동해	
	-> 쌀창고에 데이터를 보냄
		-> 타입을 알아야 어디서 보내야 할 지 정해줄 수 있음
	-> 쌀 가공
		-> 잘못된 타입을 알릴 경우 그 데이터가 다른 가공 공장으로 가게 되어 에러가 남
	-> 따로 공부를 해야 한다.

* Welcome File List
	-> A가 어디로 갈지 모르고 데이터도 안 들고 옴
	-> 문지기 입장에서는 어디로 보내야 할까? 정의가 존재함
	-> 관리자曰 아무 이유 없이 들어온 애들은 가운데 광장으로 보내
	-> Welcome File List 설정하기 나름이다.

*Error pages 처리
	-> A는 성 안에 존재하지 않은 엉뚱한 주소를 담고 있다.
	-> 문지기는 당황
	-> 관라지曰 문지기야, 네가 모르는 곳으로 가려고 하면 Error page로 던져라.
			이상한 놈들이 있는, 이상한 광장으로 보내.

* 리스너 / 필터 설정
	-> 필터 : A가 들어왔을 때 A의 신분을 확인 일치하지 않으면 입장 불가
			A가 총을 가지고 왔는데 해당 나라는 총기 소지 불법이면 총을 빼앗고 나라에 들여 보냄
	-> 리스너 :  성 안에 높은 관리자의 집이 있음. 양반이 존재. 술 친구를 필요로 함
			관리자曰 : 술 친구를 찾아라
			문지기曰 : 문서에 적힌 일만 해도 바쁘다.
			-> 리스너 : 술 잘 마시는 사람만 확인하는 대리인, 같이 입구에서 일하지만 각각의 역할 분담
					실제로 술을 먹여봄 괜찮으면 문지기에게 자기가 관리하겠다고 통보하고 양반에게 보냄

* 보안
	-> 이상한 사람 들어오면 보내고 보내고 보내고
	-> 현상수배범은 감옥으로~ 

최초에 한 번 web.xml을 확인한다.
web.xml이 하는 일이 너무 많다.


1 . FrontController 패턴
	* Servlet/JSP에 대한 정의
	* Servlet/JSP 매핑

요청이 오면 아파치(웹서처)는 요청이 URI이거나 자바 파일 일 때 톰캣에서 제어권을 넘김
톰캣에서 request, response 객체를 자동으로 생성한다. 그런 다음 web.xml을 확인한다.
web.xml은 Servlet/JSP 매핑 너무 많이 들어있으면 너무 복잡해진다.
특정 주소(.do)로 들어오게 되면 특정 주소(.do)는 FrontController 네가 낚아채!라는 세팅을 한다.
FrontController에서는 자원을 찾아갈 수 있게 FrontController가 다시 한 번 request한다. (내부에서는 자원 접근 가능)
그럼 처음에 클라이언트에서 요청한 request, response 값이 사라진다.
기존의 request, response 값이 유지 되는 기술을 필요로 함

2. RequestDispatcher 
->requestDispatcher를 사용함. 기존의 request, response 값은 그대로 유지한다.
	데이터를 들고 이동할 수 있는 기법.

3. DispatcherServlet
FrontController 패턴을 짜거나 RequestDispatcher를 직접 구현 할 필요가 없다.
DispatcherServlet이 스프링에서 제공하고 있기 때문이다. 
DispatcherServlet = FrontController패턴 + RequestDispatcher이다.

DispatcherServlet이 자동 생성되어 질 때 수 많은 객체가 생성(IoC)된다. 보통 필터들이다. (@Configuration 등등)
해당 필터들은 내가 직접 등록할 수 있고 기본적으로 필요한 필터들은 자동 등록 되어진다.

4. 스프링 컨테이너
DispatcherServlet에 의해 생성되어지는 수 많은 객체들은 어디에서 관리될까?
	-> 주소 분배
		-> 어떤 주소로 들어왔을 때 어디로 가라

4-a. ApplicationContext
	-> 요청이 오면 web.xml을 확인한다.
	-> DispatcherServlet 진입 전에 ContextLoaderListener를 집입한다.
		-> servlet은 독립적으로 스레드로 실행된다. 하지만 공통적으로 쓰이는 게 있음
		-> DB!!! 모든 스레드가 공통적으로 사용해도 되는 것들 미리 ContextLoaderListener를 통해서
			띄운다.
		-> ContextLoaderListener는 'applicationContext.xml'(root-context.xml)라는 파일을 읽는다.
			-> 따로 쓰여져야 하는 거 말고 공통적으로 쓰여져야 하는 애들을 읽는다.
				-> IoC 컨테이너에서 관리함
		-> xml 파일로 커스터마이징 할 수 있고, 자바 파일로 커스터마이징 할 수 있음
	-> spting을 사용하므로 DispatcherServlet이 동작한다.
	-> DispatcherServlet 컴포넌트 스캔을 한다.
		->어디로 가게 하려면 어디로 가려는 class가 존재
		-> class가 메모리에 떠있어야 보낼 수 있음
		-> static은 main()가 실행되기 전부터 메모리에 떠있음
		-> 그렇다고 모든 변수에 static를 붙이면
		-> 모든 사람들이 동시에 접속하여 사용하는데 메모리 충돌이 일어난다.
		-> 그래서 모든 곳에 static을 붙이지 못한다.
		-> 하나의 자원이지만 새롭게 태어나야 하는 친구들임 new연산자 - > 메모리를 띄움
		-> spring에서는 IoC를 해줘야 하는데 우리는 안 함 그럼? 
		-> 컴포넌트 스캔을 하는 DispatcherServlet이 해줌
		-> 어노테이션 기법으로 확인한다.  --> 메모리에 띄움
	-> 주소 분배 가능하다.
	-> DB는 각각의 클래스에 접근하지 못한다. 다음 단계로 넘어가지 않았기 때문에. 그것은 즉 메모리에 띄어놓지 않았다는 것.
		-> 반대는 가능하다. 그래서 DB를 메모리에 띄어서 클래스들이 필요할 때마다 가져다 쓴다.

수 많은 객체들이 ApplicationContext에 등록된다. 이것을 IoC라고 한다. IoC란 제어의 역전이다.
개발자가 직접 new()를 하게 되면 해당 객체를 가르키는 래퍼런스를 관리하기 힘들어진다. (유지보수 떨어짐)
그래서 스프링이 객체를 직접 관리한다. 이때 우리는 주소를 몰라도 된다. 왜냐하면 필요할 때 DI하면 되기 때문이다.
DI는 의존성 주입니다. 필요한 곳에서 ApplicationContext에 접근하여 필요한 객체를 가져올 수 있다.
ApplicationContext은 싱글톤으로 관리되기 때문에 어디에서 접근하든 동일한 객체라는 것을 보장한다.
------> 어떤 어노테이션을 붙여야 IoC가 괸리할 수 있는 객체인지 공부를 해야 한다.

ApplicationContext에는 두 가지의 종류가 있다.

4-a-1. servlet-applicationContext는 ViewResolver, Interceptor, MultipartResolver 객체를 생성하고 웹과 관련된 어노테이션
	Controller, RestController를 스캔한다.
		해당 파일은 DispatcherServlet에 의해 실행된다.

4-a-2. root-applicationContext는 해당 어노테이션을 제외한 어노테이션 Service, Repository등을 스캔한다.
	DB관련된 객체를 생성한다. (스캔 = 메모리에 로딩한다)
		해당 파일은 ContextLoaderListener에 의해 실행된다. ContextLoaderListener는 web.xml이기 때문에 	
		servlet-applicationContext 보다 root-applicationContext이 먼저 로드된다.
		servlet-applicationContext에서 생성한 객체는 root-applicationContext에서 생성한 객체를 참조할 수 있지만
		그 반대는 불가능하다. 생성 시기를 이해하면 된다.

4-b. Bean Factory
	필요한 객체를 Bean Factory에 등록할 수 있다. 여기에 등록하면 초기에 메모리에 로드 되지 않는다.
	필요할 때 getBean() 메소드를 호출하여 메모리에 로드할 수 있다. IoC이다.
	필요할 때 DI하여 사용할 수 있다. 
	ApplicationContext와의 차이점은 Bean Factory에서 로드되는 객체들은
	미리 로드되지 않고 필요할 때 로드되기 때문에 lazy-loading이 된다는 점이다.
	해당 클래스에 @Configuration 어노테이션을 붙임
	객체를 리턴하는 메소드가 있다면 @Bean 어노테이션을 붙임

------------------------------------------------------------------------------------------------------------------------
요청 주소에 따른 적절한 컨트롤러로 요청(Handler Mapping)
	GET 요청 시 http://localhost:8080/post/1
	해당 주소 요처이 오면 적절한 컨트롤러의 함수를 찾아서 실행한다.

응답
	html파일을 응답할지 Data를 응답할지 결정해야 한다. html 파일을 응답하게 되면 ViewResolver가 관여한다.
	Data를 응답하게 되면 MessageConverter가 작동하는데 메세지 컨버팅할 때는 json방식이다. 
	해당 메소드에 @ResponseBody 어노테이션을 붙이면 된다.
		--> 그래서 객체를 리턴하면 json방식으로 웹브라우저에 보이는 거 같다.


------------------------------- 나중에 수업 내용대로 성을 생각하며 이해를 해보자 --------------------------------
